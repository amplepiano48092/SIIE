import tkinter as tk
from tkinter import ttk, messagebox
from PIL import Image, ImageTk
import pandas as pd
import os
import json
from datetime import datetime, timedelta
import sys
import re
import serial
import serial.tools.list_ports
import threading
import time
from queue import Queue
import traceback

# ========== CONFIGURAÇÃO INICIAL ==========
app = tk.Tk()
app.title('SIIE - Sistema Interno de Informações de Estágio')
app.geometry('500x700')
app.resizable(False, False)

# Caminhos dos arquivos de dados
USERS_FILE = "usuarios.json"
DATA_FILE = "dados.xlsx"
CARTOES_FILE = "cartoes.json"
LOG_FILE = "log_rfid.txt"

# ========== VARIÁVEIS GLOBAIS ==========
ser = None
serial_thread = None
running = False
current_connection_status = "Desconectado"
auto_connect_enabled = False
auto_connect_thread = None
serial_lock = threading.Lock()  # Lock para sincronizar acesso serial
reconnect_attempts = 0
MAX_RECONNECT_ATTEMPTS = 5

# ========== FUNÇÕES DE LOG ==========
def log_event(mensagem):
    """Registra eventos no arquivo de log"""
    try:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            f.write(f"[{timestamp}] {mensagem}\n")
        print(f"[LOG] {mensagem}")
    except Exception as e:
        print(f"Erro ao registrar log: {e}")

# ========== FUNÇÕES DE CARREGAMENTO/SAVAMENTO ==========
def carregar_usuarios():
    """Carrega usuários do arquivo JSON"""
    if os.path.exists(USERS_FILE):
        try:
            with open(USERS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"Erro ao carregar usuários: {e}")
            return {}
    return {}

def salvar_usuarios(dados):
    """Salva usuários no arquivo JSON"""
    try:
        with open(USERS_FILE, 'w', encoding='utf-8') as f:
            json.dump(dados, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"Erro ao salvar usuários: {e}")

def carregar_cartoes():
    """Carrega cartões do arquivo JSON"""
    if os.path.exists(CARTOES_FILE):
        try:
            with open(CARTOES_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"Erro ao carregar cartões: {e}")
    
    # Estrutura padrão
    return {
        "ED 5A 5B 2F": {"dono": "", "ativo": True},
        "97 66 EC D8": {"dono": "", "ativo": True},
        "A7 D6 DE D7": {"dono": "", "ativo": True},
        "57 B4 EF D8": {"dono": "", "ativo": True}
    }

def salvar_cartoes(dados):
    """Salva cartões no arquivo JSON"""
    try:
        with open(CARTOES_FILE, 'w', encoding='utf-8') as f:
            json.dump(dados, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"Erro ao salvar cartões: {e}")

def carregar_dados_xlsx():
    """Carrega dados do arquivo Excel"""
    if os.path.exists(DATA_FILE):
        try:
            return pd.read_excel(DATA_FILE)
        except Exception as e:
            print(f"Erro ao carregar dados Excel: {e}")
    
    return pd.DataFrame(columns=['Usuario', 'Data', 'Entrada', 'Saida', 'Horas', 'Cartao'])

def salvar_dados_xlsx(df):
    """Salva dados no arquivo Excel"""
    try:
        df.to_excel(DATA_FILE, index=False)
    except Exception as e:
        print(f"Erro ao salvar dados Excel: {e}")

# ========== FUNÇÃO PARA CALCULAR HORAS ==========
def calcular_horas_usuario(usuario_nome):
    """Calcula o total de horas de um usuário específico"""
    df = carregar_dados_xlsx()
    
    if df.empty:
        return 0.0, []
    
    registros_usuario = df[df['Usuario'] == usuario_nome]
    
    if registros_usuario.empty:
        return 0.0, []
    
    total_horas = 0.0
    registros_detalhados = []
    
    for idx, row in registros_usuario.iterrows():
        try:
            horas_str = str(row['Horas'])
            if horas_str and horas_str not in ['nan', 'NaT', '']:
                # Converter para timedelta
                try:
                    if 'day' in horas_str:
                        # Formato com dias
                        partes = horas_str.split()
                        dias = int(partes[0])
                        tempo = partes[2]
                        horas, minutos, segundos = map(int, tempo.split(':'))
                        total_segundos = dias * 86400 + horas * 3600 + minutos * 60 + segundos
                    else:
                        # Formato HH:MM:SS
                        horas, minutos, segundos = map(int, horas_str.split(':'))
                        total_segundos = horas * 3600 + minutos * 60 + segundos
                except:
                    try:
                        td = pd.Timedelta(horas_str)
                        total_segundos = td.total_seconds()
                    except:
                        continue
                
                horas_totais = total_segundos / 3600
                total_horas += horas_totais
                
                horas_int = int(horas_totais)
                minutos_int = int((horas_totais - horas_int) * 60)
                
                registros_detalhados.append({
                    'data': row['Data'],
                    'entrada': row['Entrada'],
                    'saida': row['Saida'],
                    'horas': f"{horas_int}h{minutos_int:02d}min"
                })
        except Exception as e:
            print(f"Erro ao processar linha {idx}: {e}")
            continue
    
    return total_horas, registros_detalhados

# ========== FUNÇÕES PARA ADICIONAR/EDITAR CARTÃO ==========
def adicionar_cartao(uid, dono="", ativo=True):
    """Adiciona um novo cartão ao sistema"""
    if not uid or not uid.strip():
        return False, "UID do cartão não pode ser vazio!"
    
    uid = uid.strip().upper()
    
    if not re.match(r'^[A-F0-9\s]+$', uid):
        return False, "UID deve conter apenas letras A-F, números 0-9 e espaços!"
    
    cartoes = carregar_cartoes()
    
    if uid in cartoes:
        return False, f"Cartão com UID '{uid}' já existe no sistema!"
    
    cartoes[uid] = {
        "dono": dono,
        "ativo": ativo,
        "data_cadastro": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    
    try:
        salvar_cartoes(cartoes)
        return True, f"Cartão '{uid}' adicionado com sucesso!"
    except Exception as e:
        return False, f"Erro ao salvar cartão: {str(e)}"

def editar_uid_cartao(uid_antigo, uid_novo):
    """Edita o UID de um cartão existente"""
    if not uid_antigo or not uid_antigo.strip():
        return False, "UID antigo não pode ser vazio!"
    
    if not uid_novo or not uid_novo.strip():
        return False, "Novo UID não pode ser vazio!"
    
    uid_antigo = uid_antigo.strip().upper()
    uid_novo = uid_novo.strip().upper()
    
    if uid_antigo == uid_novo:
        return False, "O novo UID deve ser diferente do UID atual!"
    
    # Validação do formato do novo UID
    if not re.match(r'^[A-F0-9\s]+$', uid_novo):
        return False, "Novo UID deve conter apenas letras A-F, números 0-9 e espaços!"
    
    # Carregar dados
    cartoes = carregar_cartoes()
    dados = carregar_dados_xlsx()
    
    # Verificar se o cartão antigo existe
    if uid_antigo not in cartoes:
        return False, f"Cartão com UID '{uid_antigo}' não encontrado!"
    
    # Verificar se o novo UID já existe
    if uid_novo in cartoes:
        return False, f"Já existe um cartão com o UID '{uid_novo}'!"
    
    try:
        # Salvar informações do cartão antigo
        info_cartao = cartoes[uid_antigo]
        
        # Remover cartão antigo
        del cartoes[uid_antigo]
        
        # Adicionar cartão com novo UID
        cartoes[uid_novo] = info_cartao
        cartoes[uid_novo]['data_modificacao'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Atualizar registros no arquivo de dados
        if not dados.empty and 'Cartao' in dados.columns:
            # Substituir o UID antigo pelo novo nos registros
            dados.loc[dados['Cartao'] == uid_antigo, 'Cartao'] = uid_novo
        
        # Salvar alterações
        salvar_cartoes(cartoes)
        salvar_dados_xlsx(dados)
        
        log_event(f"UID do cartão alterado: '{uid_antigo}' → '{uid_novo}'")
        return True, f"UID do cartão alterado com sucesso de '{uid_antigo}' para '{uid_novo}'!"
        
    except Exception as e:
        log_event(f"Erro ao editar UID do cartão: {e}")
        return False, f"Erro ao editar UID do cartão: {str(e)}"

# ========== FUNÇÕES DE COMUNICAÇÃO SERIAL - CORRIGIDAS ==========
def listar_portas_serial():
    """Lista todas as portas seriais disponíveis"""
    portas = []
    try:
        for port in serial.tools.list_ports.comports():
            portas.append(port.device)
        log_event(f"Portas encontradas: {portas}")
    except Exception as e:
        log_event(f"Erro ao listar portas: {e}")
    return portas

def formatar_uid(uid_raw):
    """Formata um UID para o padrão correto (ex: A7 D6 DE D7)"""
    try:
        # Remover todos os caracteres não hexadecimais
        uid_limpo = re.sub(r'[^A-Fa-f0-9]', '', uid_raw).upper()
        
        if not uid_limpo:
            return None
        
        # Garantir comprimento par (normalmente 8 caracteres para RFID)
        if len(uid_limpo) % 2 != 0:
            uid_limpo = uid_limpo[:-1]
        
        # Formatar em pares separados por espaço
        partes = [uid_limpo[i:i+2] for i in range(0, len(uid_limpo), 2)]
        uid_formatado = ' '.join(partes)
        
        return uid_formatado
    except Exception as e:
        log_event(f"Erro ao formatar UID '{uid_raw}': {e}")
        return None

def safe_serial_close():
    """Fecha a conexão serial de forma segura"""
    global ser, running
    
    with serial_lock:
        running = False
        if ser:
            try:
                ser.reset_input_buffer()
                ser.reset_output_buffer()
                time.sleep(0.1)
                ser.close()
                ser = None
                log_event("Conexão serial fechada com segurança")
            except Exception as e:
                log_event(f"Erro ao fechar serial: {e}")
            finally:
                ser = None

def conectar_arduino(porta, baudrate=9600):
    """Conecta ao Arduino via Serial - VERSÃO CORRIGIDA"""
    global ser, running, current_connection_status, reconnect_attempts
    
    # Fecha conexão existente primeiro
    safe_serial_close()
    time.sleep(1.0)  # Aguarda para garantir liberação da porta
    
    try:
        log_event(f"Tentando conectar na porta {porta} com baudrate {baudrate}")
        
        # Configurações robustas para evitar problemas de permissão
        ser = serial.Serial(
            port=porta,
            baudrate=baudrate,
            bytesize=serial.EIGHTBITS,
            parity=serial.PARITY_NONE,
            stopbits=serial.STOPBITS_ONE,
            timeout=2.0,
            write_timeout=2.0,
            xonxoff=False,
            rtscts=False,
            dsrdtr=False
        )
        
        # Aguarda inicialização
        time.sleep(2.5)
        
        # Limpa buffers completamente
        ser.reset_input_buffer()
        ser.reset_output_buffer()
        
        # Testa a conexão
        ser.write(b"\n")  # Envia um simples newline para sincronizar
        time.sleep(0.5)
        
        # Lê qualquer resposta pendente
        if ser.in_waiting:
            resposta = ser.read(ser.in_waiting)
            log_event(f"Resposta inicial do Arduino: {resposta}")
        
        running = True
        current_connection_status = "Conectado"
        reconnect_attempts = 0
        
        # Inicia thread de leitura
        iniciar_thread_leitura()
        
        log_event(f"Conectado à porta {porta} com sucesso")
        return True, f"Conectado à {porta}"
        
    except PermissionError as e:
        erro_msg = f"Permissão negada na porta {porta}. Feche outros programas usando a porta."
        log_event(erro_msg)
        current_connection_status = "Erro de Permissão"
        safe_serial_close()
        return False, erro_msg
    except serial.SerialException as e:
        erro_msg = f"Erro na conexão serial {porta}: {str(e)}"
        log_event(erro_msg)
        current_connection_status = "Erro"
        safe_serial_close()
        return False, erro_msg
    except Exception as e:
        erro_msg = f"Erro inesperado: {str(e)}"
        log_event(erro_msg)
        current_connection_status = "Erro"
        safe_serial_close()
        return False, erro_msg

def desconectar_arduino():
    """Desconecta do Arduino de forma segura"""
    global running, current_connection_status, auto_connect_enabled
    
    log_event("Desconectando Arduino...")
    auto_connect_enabled = False
    current_connection_status = "Desconectado"
    
    safe_serial_close()
    
    if serial_thread and serial_thread.is_alive():
        try:
            serial_thread.join(timeout=2.0)
        except:
            pass
    
    log_event("Arduino desconectado com sucesso")

def iniciar_thread_leitura():
    """Inicia thread para leitura serial"""
    global serial_thread
    
    if serial_thread and serial_thread.is_alive():
        try:
            serial_thread.join(timeout=1.0)
        except:
            pass
    
    serial_thread = threading.Thread(target=ler_serial, daemon=True)
    serial_thread.start()
    log_event("Thread de leitura serial iniciada")

def ler_serial():
    """Thread para leitura contínua da serial - VERSÃO SUPER ROBUSTA"""
    global running, ser, current_connection_status, reconnect_attempts
    
    log_event("Thread de leitura serial iniciada")
    
    buffer = ""
    consecutive_errors = 0
    MAX_CONSECUTIVE_ERRORS = 10
    
    while running:
        try:
            with serial_lock:
                if not ser or not ser.is_open:
                    log_event("Porta serial não está aberta")
                    time.sleep(1)
                    continue
                
                # Lê dados disponíveis
                if ser.in_waiting > 0:
                    try:
                        # Lê todos os bytes disponíveis
                        data = ser.read(ser.in_waiting)
                        
                        # Decodifica para string
                        try:
                            decoded_data = data.decode('utf-8', errors='ignore')
                            buffer += decoded_data
                            consecutive_errors = 0  # Reseta contador de erros
                        except UnicodeDecodeError:
                            log_event("Erro de decodificação - tentando latin-1")
                            decoded_data = data.decode('latin-1', errors='ignore')
                            buffer += decoded_data
                        
                        # Processa linhas completas
                        while '\n' in buffer or '\r' in buffer:
                            # Encontra o fim da linha
                            if '\n' in buffer:
                                linha, buffer = buffer.split('\n', 1)
                            else:
                                linha, buffer = buffer.split('\r', 1)
                            
                            linha = linha.strip()
                            
                            if linha:
                                log_event(f"Dados recebidos: {linha}")
                                
                                # Processa UID
                                uid_formatado = formatar_uid(linha)
                                if uid_formatado:
                                    log_event(f"UID processado: {uid_formatado}")
                                    app.after(0, lambda uid=uid_formatado: processar_cartao_rfid(uid))
                                else:
                                    # Tenta extrair UID de mensagens do sistema
                                    uid_matches = re.findall(r'([A-F0-9]{8,})', linha.upper())
                                    for uid_match in uid_matches:
                                        uid_formatado = formatar_uid(uid_match)
                                        if uid_formatado:
                                            log_event(f"UID extraído: {uid_formatado}")
                                            app.after(0, lambda uid=uid_formatado: processar_cartao_rfid(uid))
                                            break
                    
                    except (serial.SerialException, OSError) as e:
                        consecutive_errors += 1
                        log_event(f"Erro de leitura #{consecutive_errors}: {e}")
                        
                        if consecutive_errors >= MAX_CONSECUTIVE_ERRORS:
                            log_event(f"Muitos erros consecutivos. Reconectando...")
                            current_connection_status = "Reconectando"
                            safe_serial_close()
                            time.sleep(2)
                            break
                
                # Pequena pausa para evitar uso excessivo de CPU
                time.sleep(0.01)
                
        except Exception as e:
            log_event(f"Erro inesperado na leitura serial: {e}")
            log_event(f"Traceback: {traceback.format_exc()}")
            time.sleep(0.5)
    
    log_event("Thread de leitura serial finalizada")
    
    # Tenta reconectar se ainda estiver rodando
    if running and current_connection_status == "Reconectando":
        app.after(1000, tentar_reconexao_automatica)

def tentar_reconexao_automatica():
    """Tenta reconectar automaticamente"""
    global reconnect_attempts, current_connection_status, auto_connect_enabled
    
    if auto_connect_enabled and current_connection_status != "Conectado":
        if reconnect_attempts < MAX_RECONNECT_ATTEMPTS:
            reconnect_attempts += 1
            log_event(f"Tentativa de reconexão #{reconnect_attempts}")
            mostrar_notificacao(f"Reconectando... Tentativa {reconnect_attempts}", "orange")
            conectar_automaticamente_arduino()
        else:
            log_event("Máximo de tentativas de reconexão atingido")
            mostrar_notificacao("Falha na conexão. Verifique o Arduino", "red")

def enviar_feedback_arduino(mensagem):
    """Envia feedback para o Arduino de forma segura"""
    global ser
    
    if not ser or not ser.is_open:
        return
    
    with serial_lock:
        try:
            ser.write(f"{mensagem}\n".encode())
            ser.flush()
            log_event(f"Feedback enviado: {mensagem}")
        except Exception as e:
            log_event(f"Erro ao enviar feedback: {e}")

# ========== FUNÇÕES DE CONEXÃO AUTOMÁTICA ==========
def conectar_automaticamente_arduino():
    """Tenta conectar automaticamente ao Arduino - VERSÃO CORRIGIDA"""
    global current_connection_status, auto_connect_enabled, ser, running
    
    if not auto_connect_enabled:
        return False
    
    if current_connection_status == "Conectado":
        return True
    
    log_event("Iniciando conexão automática...")
    current_connection_status = "Conectando"
    
    # Fecha conexão existente
    safe_serial_close()
    time.sleep(1.0)
    
    portas = listar_portas_serial()
    
    if not portas:
        log_event("Nenhuma porta serial disponível")
        mostrar_notificacao("Nenhuma porta serial encontrada", "orange")
        current_connection_status = "Desconectado"
        return False
    
    log_event(f"Portas disponíveis: {portas}")
    
    # Evita portas problemáticas
    portas_evitar = ['COM1', 'COM2']  # COM1/COM2 podem ser virtuais no Windows
    portas_validas = [p for p in portas if p not in portas_evitar]
    
    if not portas_validas:
        portas_validas = portas
    
    baudrates = [9600, 115200, 57600, 38400, 19200, 14400, 28800]
    
    for porta in portas_validas:
        for baudrate in baudrates:
            try:
                log_event(f"Testando {porta} @ {baudrate}...")
                
                # Tenta conectar
                sucesso, mensagem = conectar_arduino(porta, baudrate)
                
                if sucesso:
                    log_event(f"Conexão automática bem-sucedida: {porta}")
                    mostrar_notificacao(f"Conectado a {porta}", "green")
                    return True
                else:
                    log_event(f"Falha em {porta}@{baudrate}: {mensagem}")
                    
            except Exception as e:
                log_event(f"Erro ao testar {porta}: {e}")
                time.sleep(0.5)
    
    log_event("Conexão automática falhou em todas as portas")
    current_connection_status = "Desconectado"
    mostrar_notificacao("Não foi possível conectar ao Arduino", "red")
    return False

def iniciar_conexao_automatica():
    """Inicia a thread de conexão automática"""
    global auto_connect_enabled, auto_connect_thread
    
    if auto_connect_enabled:
        return
    
    auto_connect_enabled = True
    
    def thread_conexao_automatica():
        log_event("Thread de conexão automática iniciada")
        
        while auto_connect_enabled:
            if current_connection_status != "Conectado":
                conectar_automaticamente_arduino()
            
            # Verifica a cada 10 segundos se precisa reconectar
            for _ in range(20):  # 20 * 0.5 = 10 segundos
                if not auto_connect_enabled:
                    break
                time.sleep(0.5)
    
    if auto_connect_thread is None or not auto_connect_thread.is_alive():
        auto_connect_thread = threading.Thread(target=thread_conexao_automatica, daemon=True)
        auto_connect_thread.start()

def parar_conexao_automatica():
    """Para a conexão automática"""
    global auto_connect_enabled
    auto_connect_enabled = False
    log_event("Conexão automática desativada")

def reconectar_manualmente():
    """Tenta reconectar manualmente ao Arduino"""
    global current_connection_status
    
    if current_connection_status == "Conectado":
        messagebox.showinfo("Informação", "Já conectado ao Arduino!")
        return
    
    log_event("Tentativa de reconexão manual iniciada")
    mostrar_notificacao("Tentando reconectar...", "blue")
    
    # Para conexão automática temporariamente
    auto_connect_temp = auto_connect_enabled
    parar_conexao_automatica()
    
    sucesso = conectar_automaticamente_arduino()
    
    # Restaura configuração anterior
    if auto_connect_temp:
        iniciar_conexao_automatica()
    
    if sucesso:
        messagebox.showinfo("Sucesso", "Reconectado com sucesso!")
    else:
        messagebox.showwarning("Aviso", "Não foi possível reconectar. Verifique:\n1. Arduino está ligado\n2. Cabo USB está conectado\n3. Nenhum outro programa usando a porta\n4. Drivers instalados corretamente")

# ========== PROCESSAMENTO DE CARTÕES RFID ==========
def processar_cartao_rfid(uid):
    """Processa leitura do cartão RFID"""
    try:
        log_event(f"=== PROCESSANDO CARTÃO RFID ===")
        log_event(f"UID recebido: '{uid}'")
        
        cartoes = carregar_cartoes()
        usuarios = carregar_usuarios()
        
        log_event(f"Total de cartões no sistema: {len(cartoes)}")
        
        # Normalizar o UID
        uid_normalizado = ' '.join(uid.split())
        
        # Verificar se cartão existe
        cartao_encontrado = None
        cartao_info = None
        
        if uid_normalizado in cartoes:
            cartao_encontrado = uid_normalizado
            cartao_info = cartoes[uid_normalizado]
        else:
            uid_sem_espacos = uid_normalizado.replace(' ', '')
            for cartao_uid in cartoes.keys():
                if cartao_uid.replace(' ', '') == uid_sem_espacos:
                    cartao_encontrado = cartao_uid
                    cartao_info = cartoes[cartao_uid]
                    break
        
        if not cartao_encontrado:
            log_event(f"Cartão NÃO cadastrado: '{uid_normalizado}'")
            mostrar_notificacao(f"Cartão não cadastrado: {uid_normalizado}", "red")
            enviar_feedback_arduino("NAO_CADASTRADO")
            return
        
        log_event(f"Cartão encontrado: {cartao_encontrado}")
        
        # Verifica se cartão está ativo
        if not cartao_info.get('ativo', True):
            log_event(f"Cartão INATIVO: {cartao_encontrado}")
            mostrar_notificacao(f"Cartão inativo: {cartao_encontrado}", "orange")
            enviar_feedback_arduino("INATIVO")
            return
        
        # Verifica se tem dono
        dono = cartao_info.get('dono', '')
        if not dono:
            log_event(f"Cartão SEM DONO: {cartao_encontrado}")
            mostrar_notificacao(f"Cartão sem dono associado", "orange")
            enviar_feedback_arduino("SEM_DONO")
            return
        
        # Verificar se dono existe
        if dono not in usuarios:
            log_event(f"ERRO: Dono '{dono}' não encontrado nos usuários")
            mostrar_notificacao(f"Usuário não encontrado: {dono}", "red")
            enviar_feedback_arduino("SEM_DONO")
            return
        
        log_event(f"Cartão válido - Dono: {dono}")
        
        # Registra ponto
        registrar_ponto_automatico(dono, cartao_encontrado)
        
        log_event(f"Cartão processado com sucesso: {cartao_encontrado} - Dono: {dono}")
        
    except Exception as e:
        log_event(f"ERRO ao processar cartão: {e}")
        log_event(traceback.format_exc())
        mostrar_notificacao(f"Erro ao processar cartão", "red")

def registrar_ponto_automatico(usuario, uid):
    """Registra entrada/saída automaticamente"""
    try:
        agora = datetime.now()
        data_str = agora.strftime("%d/%m/%Y")
        hora_str = agora.strftime("%H:%M")
        
        log_event(f"Tentando registrar ponto para {usuario}")
        log_event(f"Data: {data_str}, Hora: {hora_str}")
        
        df = carregar_dados_xlsx()
        
        log_event(f"DataFrame atual - Total registros: {len(df)}")
        
        # Filtra registros do usuário HOJE
        registros_hoje = df[
            (df['Usuario'] == usuario) & 
            (df['Data'] == data_str)
        ]
        
        log_event(f"Registros de hoje para {usuario}: {len(registros_hoje)}")
        
        # Determinar se é entrada ou saída
        if registros_hoje.empty:
            # Primeiro registro do dia - ENTRADA
            log_event(f"Primeiro registro do dia - Registrando ENTRADA")
            
            novo_registro = {
                'Usuario': usuario,
                'Data': data_str,
                'Entrada': hora_str,
                'Saida': '',
                'Horas': '',
                'Cartao': uid
            }
            df = pd.concat([df, pd.DataFrame([novo_registro])], ignore_index=True)
            
            mensagem = f"ENTRADA registrada\n{usuario}\n{hora_str}"
            mostrar_notificacao(mensagem, "green")
            enviar_feedback_arduino("ENTRADA_OK")
            log_event(f"Entrada registrada com sucesso: {usuario} - {hora_str}")
            
        else:
            # Verificar o último registro
            ultimo_registro = registros_hoje.iloc[-1]
            log_event(f"Último registro:\n{ultimo_registro}")
            
            # Verificar se já tem saída registrada
            saida_vazia = pd.isna(ultimo_registro['Saida']) or str(ultimo_registro['Saida']).strip() == ''
            
            if saida_vazia:
                # Tem entrada mas não tem saída - registrar SAÍDA
                log_event(f"Registro sem saída - Registrando SAÍDA")
                
                idx = registros_hoje.index[-1]
                entrada_str = str(df.at[idx, 'Entrada'])
                df.at[idx, 'Saida'] = hora_str
                
                try:
                    entrada_dt = datetime.strptime(f"{data_str} {entrada_str}", "%d/%m/%Y %H:%M")
                    saida_dt = datetime.strptime(f"{data_str} {hora_str}", "%d/%m/%Y %H:%M")
                    
                    if saida_dt <= entrada_dt:
                        mostrar_notificacao("Hora de saída inválida", "orange")
                        enviar_feedback_arduino("ERRO_HORA")
                        return
                    
                    horas = saida_dt - entrada_dt
                    df.at[idx, 'Horas'] = str(horas)
                    
                    horas_total = horas.seconds // 3600
                    minutos_total = (horas.seconds % 3600) // 60
                    
                    mensagem = f"SAÍDA registrada\n{usuario}\n{hora_str}\nTotal: {horas_total}h{minutos_total:02d}min"
                    mostrar_notificacao(mensagem, "blue")
                    enviar_feedback_arduino("SAIDA_OK")
                    log_event(f"Saída registrada: {usuario} - {hora_str} - Total: {horas_total}h{minutos_total:02d}min")
                    
                except Exception as e:
                    df.at[idx, 'Horas'] = 'Erro no cálculo'
                    mensagem = f"SAÍDA registrada\n{usuario}\n{hora_str}\n(Erro no cálculo)"
                    mostrar_notificacao(mensagem, "orange")
                    enviar_feedback_arduino("ERRO_CALCULO")
                    log_event(f"Erro no cálculo de horas: {e}")
            else:
                # Já tem entrada e saída - registrar nova ENTRADA
                log_event(f"Já tem entrada e saída - Registrando NOVA ENTRADA")
                
                novo_registro = {
                    'Usuario': usuario,
                    'Data': data_str,
                    'Entrada': hora_str,
                    'Saida': '',
                    'Horas': '',
                    'Cartao': uid
                }
                df = pd.concat([df, pd.DataFrame([novo_registro])], ignore_index=True)
                
                mensagem = f"ENTRADA registrada\n{usuario}\n{hora_str}"
                mostrar_notificacao(mensagem, "green")
                enviar_feedback_arduino("ENTRADA_OK")
                log_event(f"Nova entrada registrada: {usuario} - {hora_str}")
        
        # Salva dados
        salvar_dados_xlsx(df)
        log_event(f"Dados salvos com sucesso")
        
    except Exception as e:
        log_event(f"ERRO ao registrar ponto: {e}")
        log_event(traceback.format_exc())
        mostrar_notificacao(f"Erro ao registrar ponto", "red")
        enviar_feedback_arduino("ERRO_GERAL")

# ========== TESTE DE COMUNICAÇÃO SERIAL ==========
def testar_comunicacao_serial():
    """Testa a comunicação serial com o Arduino"""
    if not ser or not ser.is_open:
        messagebox.showwarning("Aviso", "Não conectado ao Arduino!")
        return
    
    try:
        with serial_lock:
            ser.reset_input_buffer()
            ser.reset_output_buffer()
            
            ser.write(b"TEST\n")
            ser.flush()
            
            time.sleep(0.5)
            
            if ser.in_waiting > 0:
                resposta = ser.readline().decode('utf-8', errors='ignore').strip()
                log_event(f"Resposta do Arduino: {resposta}")
                messagebox.showinfo("Teste", f"Conexão OK!\nArduino respondeu: {resposta}")
            else:
                log_event("Arduino não respondeu ao teste")
                messagebox.showwarning("Teste", "Arduino não respondeu. Verifique a conexão.")
                
    except Exception as e:
        log_event(f"Erro no teste de comunicação: {e}")
        messagebox.showerror("Erro", f"Falha na comunicação: {e}")

# ========== NOTIFICAÇÃO NA INTERFACE PRINCIPAL ==========
notif_var = tk.StringVar()
notif_var.set("Sistema pronto. Configure a conexão Arduino.")

def mostrar_notificacao(mensagem, cor="black"):
    """Mostra notificação na interface principal"""
    notif_var.set(mensagem)
    
    if hasattr(app, 'notif_label'):
        app.notif_label.config(fg=cor)
    
    app.after(5000, lambda: notif_var.set("Aguardando cartão RFID..."))

# ========== INTERFACE DE CONFIGURAÇÃO SERIAL ==========
def configuracao_serial():
    """Janela de configuração da conexão serial"""
    config_janela = tk.Toplevel(app)
    config_janela.title("Configuração de Conexão Arduino")
    config_janela.geometry("675x700")
    config_janela.resizable(False, False)
    
    # Frame principal com scroll
    main_frame = tk.Frame(config_janela)
    main_frame.pack(fill='both', expand=True)
    
    canvas = tk.Canvas(main_frame)
    scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)
    
    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )
    
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)
    
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")
    
    def _on_mousewheel(event):
        canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    
    canvas.bind_all("<MouseWheel>", _on_mousewheel)
    
    # Título
    tk.Label(scrollable_frame, text="CONEXÃO COM ARDUINO RFID", 
             font=('Times New Roman', 16, 'bold')).pack(pady=(20, 10))
    
    # Frame para conexão automática
    auto_frame = tk.Frame(scrollable_frame, padx=20)
    auto_frame.pack(fill='x', pady=(0, 15))
    
    tk.Label(auto_frame, text="Conexão Automática:", 
             font=('Times New Roman', 11, 'bold')).pack(anchor='w')
    
    auto_desc = tk.Label(auto_frame, 
                        text="O sistema tentará detectar e conectar automaticamente ao Arduino",
                        font=('Times New Roman', 9), wraplength=400, justify='left')
    auto_desc.pack(anchor='w', pady=(0, 10))
    
    auto_buttons_frame = tk.Frame(auto_frame)
    auto_buttons_frame.pack(fill='x')
    
    def ativar_auto_conexao():
        iniciar_conexao_automatica()
        mostrar_notificacao("Conexão automática ativada", "green")
        log_event("Conexão automática ativada pelo usuário")
    
    def desativar_auto_conexao():
        parar_conexao_automatica()
        mostrar_notificacao("Conexão automática desativada", "orange")
        log_event("Conexão automática desativada pelo usuário")
    
    tk.Button(auto_buttons_frame, text="Ativar Conexão Automática", 
              font=('Times New Roman', 9),
              command=ativar_auto_conexao, bg='#4CAF50', fg='white',
              padx=10, pady=5).pack(side='left', padx=5)
    
    tk.Button(auto_buttons_frame, text="Desativar Conexão Automática", 
              font=('Times New Roman', 9),
              command=desativar_auto_conexao, bg='#F44336', fg='white',
              padx=10, pady=5).pack(side='left', padx=5)
    
    tk.Frame(scrollable_frame, height=2, bg='#ddd').pack(fill='x', padx=20, pady=10)
    
    # Frame para seleção de porta
    porta_frame = tk.Frame(scrollable_frame, padx=20)
    porta_frame.pack(fill='x', pady=10)
    
    tk.Label(porta_frame, text="Porta Serial (COM):", 
             font=('Times New Roman', 11)).pack(anchor='w')
    
    porta_combo = ttk.Combobox(porta_frame, font=('Times New Roman', 11))
    porta_combo.pack(fill='x', pady=5)
    
    def atualizar_portas():
        portas = listar_portas_serial()
        if portas:
            porta_combo['values'] = portas
            if portas:
                porta_combo.set(portas[0])
        else:
            porta_combo['values'] = ["Nenhuma porta encontrada"]
            porta_combo.set("Nenhuma porta encontrada")
    
    tk.Button(porta_frame, text="Atualizar Portas", 
              font=('Times New Roman', 9),
              command=atualizar_portas, bg='#2196F3', fg='white').pack(pady=5)
    
    # Frame para configurações
    config_frame = tk.Frame(scrollable_frame, padx=20)
    config_frame.pack(fill='x', pady=10)
    
    baud_frame = tk.Frame(config_frame)
    baud_frame.pack(fill='x', pady=5)
    
    tk.Label(baud_frame, text="Baudrate:", 
             font=('Times New Roman', 11)).pack(side='left')
    
    baud_var = tk.StringVar(value="9600")
    baud_combo = ttk.Combobox(baud_frame, textvariable=baud_var, 
                              values=["9600", "115200", "57600", "38400", "19200"],
                              font=('Times New Roman', 11), width=10, state='readonly')
    baud_combo.pack(side='left', padx=10)
    
    # Status da conexão
    status_frame = tk.Frame(scrollable_frame, padx=20)
    status_frame.pack(fill='x', pady=15)
    
    status_var = tk.StringVar(value=current_connection_status)
    
    tk.Label(status_frame, text="Status da Conexão:", 
             font=('Times New Roman', 11, 'bold')).pack(anchor='w')
    
    status_label = tk.Label(status_frame, textvariable=status_var, 
                           font=('Times New Roman', 11, 'bold'))
    status_label.pack(anchor='w', pady=5)
    
    def atualizar_status():
        status_var.set(current_connection_status)
        if current_connection_status == "Conectado":
            status_label.config(fg='green')
        elif current_connection_status == "Erro de Permissão":
            status_label.config(fg='red')
        elif current_connection_status in ["Conectando", "Reconectando"]:
            status_label.config(fg='orange')
        else:
            status_label.config(fg='gray')
        config_janela.after(1000, atualizar_status)
    
    # Log de eventos
    log_frame = tk.Frame(scrollable_frame, padx=20)
    log_frame.pack(fill='both', expand=True, pady=10)
    
    tk.Label(log_frame, text="Log de Eventos RFID:", 
             font=('Times New Roman', 11, 'bold')).pack(anchor='w')
    
    log_text = tk.Text(log_frame, height=8, font=('Courier New', 9), wrap=tk.WORD)
    scrollbar_log = tk.Scrollbar(log_frame)
    log_text.configure(yscrollcommand=scrollbar_log.set)
    scrollbar_log.config(command=log_text.yview)
    
    log_text.pack(side='left', fill='both', expand=True)
    scrollbar_log.pack(side='right', fill='y')
    
    def atualizar_log():
        try:
            if os.path.exists(LOG_FILE):
                with open(LOG_FILE, 'r', encoding='utf-8') as f:
                    linhas = f.readlines()[-15:]
                    log_text.delete(1.0, tk.END)
                    for linha in linhas:
                        log_text.insert(tk.END, linha)
        except:
            pass
        
        config_janela.after(2000, atualizar_log)
    
    # Funções dos botões
    def conectar():
        porta = porta_combo.get()
        if not porta or "Nenhuma porta" in porta:
            messagebox.showwarning("Aviso", "Selecione uma porta válida!")
            return
        
        try:
            baud = int(baud_var.get())
        except:
            baud = 9600
        
        sucesso, mensagem = conectar_arduino(porta, baud)
        
        if sucesso:
            messagebox.showinfo("Sucesso", mensagem)
        else:
            messagebox.showerror("Erro", mensagem)
    
    def desconectar_interface():
        desconectar_arduino()
        messagebox.showinfo("Info", "Desconectado do Arduino")
    
    # Frame para botões
    botoes_frame = tk.Frame(scrollable_frame, padx=20)
    botoes_frame.pack(fill='x', pady=15)
    
    tk.Button(botoes_frame, text="Conectar", 
              command=conectar, bg='#4CAF50', fg='white',
              padx=15, pady=8, font=('Times New Roman', 10)).pack(side='left', padx=5)
    
    tk.Button(botoes_frame, text="Desconectar", 
              command=desconectar_interface, bg='#F44336', fg='white',
              padx=15, pady=8, font=('Times New Roman', 10)).pack(side='left', padx=5)
    
    tk.Button(botoes_frame, text="Testar Conexão", 
              command=testar_comunicacao_serial, bg='#2196F3', fg='white',
              padx=15, pady=8, font=('Times New Roman', 10)).pack(side='left', padx=5)
    
    tk.Button(botoes_frame, text="Reconectar", 
              command=reconectar_manualmente, bg='#9C27B0', fg='white',
              padx=15, pady=8, font=('Times New Roman', 10)).pack(side='left', padx=5)
    
    # Botão de solução de problemas
    tk.Button(botoes_frame, text="Solução de Problemas", 
              command=lambda: messagebox.showinfo("Solução de Problemas",
              """1. Feche todos os programas usando a porta COM
2. Reinicie o Arduino
3. Tente outra porta USB
4. Verifique drivers do Arduino
5. Execute o programa como Administrador"""),
              bg='#FF9800', fg='white',
              padx=15, pady=8, font=('Times New Roman', 10)).pack(side='left', padx=5)
    
    # Inicializar
    atualizar_portas()
    atualizar_status()
    atualizar_log()
    
    def fechar_janela():
        config_janela.destroy()
    
    config_janela.protocol("WM_DELETE_WINDOW", fechar_janela)
    config_janela.bind("<MouseWheel>", lambda e: canvas.yview_scroll(int(-1*(e.delta/120)), "units"))

# ========== INTERFACE DE DADOS E RELATÓRIOS ==========
def dadoss():
    app.withdraw()
    dados = tk.Toplevel()
    dados.title('SIIE - Dados e Relatórios')
    dados.geometry('575x650')
    dados.resizable(False, False)
    
    main_frame = tk.Frame(dados)
    main_frame.pack(fill='both', expand=True)
    
    canvas = tk.Canvas(main_frame)
    scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)
    
    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )
    
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)
    
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")
    
    def _on_mousewheel(event):
        canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    
    canvas.bind_all("<MouseWheel>", _on_mousewheel)
    
    titulo_frame = tk.Frame(scrollable_frame, padx=20)
    titulo_frame.pack(fill='x', pady=(20, 10))
    
    tk.Label(titulo_frame, text='DADOS E RELATÓRIOS', 
             font=('Times New Roman', 18, 'bold')).pack()
    tk.Label(titulo_frame, text='Selecione um usuário para ver suas horas detalhadas',
             font=('Times New Roman', 10)).pack()
    
    colunas_frame = tk.Frame(scrollable_frame, padx=20)
    colunas_frame.pack(fill='both', expand=True)
    
    coluna_esquerda = tk.Frame(colunas_frame, bg='#f5f5f5')
    coluna_esquerda.pack(side='left', fill='both', padx=(0, 10))
    
    tk.Label(coluna_esquerda, text='LISTA DE USUÁRIOS', 
             font=('Times New Roman', 12, 'bold'), bg='#f5f5f5', pady=10).pack()
    
    lista_frame = tk.Frame(coluna_esquerda)
    lista_frame.pack(fill='both', expand=True, padx=10, pady=10)
    
    lista_usuarios = tk.Listbox(lista_frame, font=('Times New Roman', 11), 
                               selectmode='single', height=12)
    scrollbar_lista = tk.Scrollbar(lista_frame)
    lista_usuarios.configure(yscrollcommand=scrollbar_lista.set)
    scrollbar_lista.config(command=lista_usuarios.yview)
    
    lista_usuarios.pack(side='left', fill='both', expand=True)
    scrollbar_lista.pack(side='right', fill='y')
    
    usuarios_dict = carregar_usuarios()
    for usuario in usuarios_dict.keys():
        lista_usuarios.insert(tk.END, usuario)
    
    botoes_esquerda = tk.Frame(coluna_esquerda, bg='#f5f5f5', pady=10)
    botoes_esquerda.pack(fill='x', padx=10)
    
    def atualizar_lista_usuarios():
        lista_usuarios.delete(0, tk.END)
        usuarios_dict = carregar_usuarios()
        for usuario in usuarios_dict.keys():
            lista_usuarios.insert(tk.END, usuario)
    
    tk.Button(botoes_esquerda, text="Atualizar Lista", font=('Times New Roman', 9),
              command=atualizar_lista_usuarios, bg='#2196F3', fg='white',
              padx=10, pady=5).pack(fill='x')
    
    coluna_direita = tk.Frame(colunas_frame)
    coluna_direita.pack(side='left', fill='both', expand=True)
    
    info_frame = tk.Frame(coluna_direita, relief='groove', borderwidth=2,
                         bg='#f8f9fa', padx=15, pady=15)
    info_frame.pack(fill='x', pady=(0, 20))
    
    titulo_horas = tk.Label(info_frame, text='Selecione um usuário à esquerda', 
                           font=('Times New Roman', 14, 'bold'), bg='#f8f9fa')
    titulo_horas.pack()
    
    total_horas_var = tk.StringVar()
    total_horas_var.set('')
    label_total_horas = tk.Label(info_frame, textvariable=total_horas_var,
                                font=('Times New Roman', 12), bg='#f8f9fa', fg='#2e7d32')
    label_total_horas.pack(pady=5)
    
    tree_frame = tk.Frame(coluna_direita)
    tree_frame.pack(fill='both', expand=True)
    
    tk.Label(tree_frame, text='REGISTROS DETALHADOS', 
             font=('Times New Roman', 12, 'bold')).pack(anchor='w', pady=(0, 10))
    
    tree = ttk.Treeview(tree_frame, columns=('Data', 'Entrada', 'Saida', 'Horas'), 
                        show='headings', height=8)
    
    vsb = ttk.Scrollbar(tree_frame, orient="vertical", command=tree.yview)
    tree.configure(yscrollcommand=vsb.set)
    
    colunas_tree = [('Data', 'Data', 80),
                   ('Entrada', 'Entrada', 70),
                   ('Saida', 'Saída', 70),
                   ('Horas', 'Horas', 90)]
    
    for col, texto, largura in colunas_tree:
        tree.heading(col, text=texto)
        tree.column(col, width=largura)
    
    tree.pack(side='left', fill='both', expand=True)
    vsb.pack(side='right', fill='y')
    
    botoes_frame = tk.Frame(scrollable_frame, padx=20)
    botoes_frame.pack(fill='x', pady=20)
    
    def exibir_detalhes_usuario(event=None):
        for item in tree.get_children():
            tree.delete(item)
        
        selecao = lista_usuarios.curselection()
        if not selecao:
            titulo_horas.config(text='Selecione um usuário à esquerda')
            total_horas_var.set('')
            return
        
        usuario_nome = lista_usuarios.get(selecao[0])
        titulo_horas.config(text=f'{usuario_nome}')
        
        total_horas, registros = calcular_horas_usuario(usuario_nome)
        
        if total_horas > 0:
            horas_int = int(total_horas)
            minutos_int = int((total_horas - horas_int) * 60)
            total_texto = f'TOTAL: {horas_int}h{minutos_int:02d}min'
        else:
            total_texto = 'TOTAL: 0h00min'
        
        total_horas_var.set(total_texto)
        
        if registros:
            for registro in registros:
                tree.insert('', 'end', values=(
                    registro['data'],
                    registro['entrada'],
                    registro['saida'],
                    registro['horas']
                ))
        else:
            tree.insert('', 'end', values=('Nenhum registro encontrado', '', '', ''))
    
    lista_usuarios.bind('<<ListboxSelect>>', exibir_detalhes_usuario)
    
    def recarregar_detalhes():
        exibir_detalhes_usuario()
    
    tk.Button(botoes_frame, text="Recarregar Detalhes", font=('Times New Roman', 10),
              command=recarregar_detalhes, bg='#4CAF50', fg='white',
              padx=15, pady=8).pack(side='left', padx=5)
    
    def exportar_relatorio_usuario():
        selecao = lista_usuarios.curselection()
        if not selecao:
            messagebox.showwarning("Aviso", "Selecione um usuário para exportar!")
            return
        
        usuario_nome = lista_usuarios.get(selecao[0])
        total_horas, registros = calcular_horas_usuario(usuario_nome)
        
        try:
            with open(f'relatorio_{usuario_nome.replace(" ", "_")}.txt', 'w', encoding='utf-8') as f:
                f.write(f"RELATÓRIO INDIVIDUAL - {usuario_nome}\n")
                f.write("=" * 50 + "\n\n")
                
                horas_int = int(total_horas)
                minutos_int = int((total_horas - horas_int) * 60)
                f.write(f"TOTAL DE HORAS: {horas_int}h{minutos_int:02d}min ({total_horas:.2f} horas)\n\n")
                
                f.write("REGISTROS DETALHADOS:\n")
                f.write("-" * 50 + "\n")
                
                for registro in registros:
                    f.write(f"Data: {registro['data']}\n")
                    f.write(f"Entrada: {registro['entrada']} | Saída: {registro['saida']}\n")
                    f.write(f"Horas do dia: {registro['horas']}\n")
                    f.write("-" * 30 + "\n")
            messagebox.showinfo("Exportar", f"Relatório de {usuario_nome} exportado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar: {str(e)}")
    
    tk.Button(botoes_frame, text="Exportar Relatório", font=('Times New Roman', 10),
              command=exportar_relatorio_usuario, bg='#FF9800', fg='white',
              padx=15, pady=8).pack(side='left', padx=5)
    
    def exportar_todos_usuarios():
        usuarios_dict = carregar_usuarios()
        
        try:
            with open('relatorio_completo.txt', 'w', encoding='utf-8') as f:
                f.write("RELATÓRIO COMPLETO DE HORAS\n")
                f.write("=" * 50 + "\n\n")
                
                for usuario_nome in usuarios_dict.keys():
                    total_horas, registros = calcular_horas_usuario(usuario_nome)
                    
                    if total_horas > 0 or registros:
                        horas_int = int(total_horas)
                        minutos_int = int((total_horas - horas_int) * 60)
                        f.write(f"USUÁRIO: {usuario_nome}\n")
                        f.write(f"TOTAL: {horas_int}h{minutos_int:02d}min ({total_horas:.2f} horas)\n")
                        f.write(f"REGISTROS: {len(registros)}\n")
                        f.write("-" * 40 + "\n\n")
            
            messagebox.showinfo("Exportar", "Relatório completo exportado com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao exportar: {str(e)}")
    
    tk.Button(botoes_frame, text="Exportar Todos", font=('Times New Roman', 10),
              command=exportar_todos_usuarios, bg='#9C27B0', fg='white',
              padx=15, pady=8).pack(side='left', padx=5)
    
    def voltar_dados():
        dados.destroy()
        app.deiconify()
    
    tk.Button(scrollable_frame, text="Voltar ao Menu Principal", 
              font=('Times New Roman', 10, 'bold'),
              command=voltar_dados, bg='#757575', fg='white',
              padx=20, pady=10).pack(pady=20)
    
    dados.protocol("WM_DELETE_WINDOW", voltar_dados)
    dados.bind("<MouseWheel>", lambda e: canvas.yview_scroll(int(-1*(e.delta/120)), "units"))
    
    if lista_usuarios.size() > 0:
        lista_usuarios.selection_set(0)
        lista_usuarios.activate(0)
        dados.after(100, exibir_detalhes_usuario)

# ========== INTERFACE DE GERENCIAMENTO DE USUÁRIOS ==========
def usuarios():
    app.withdraw()
    usuario = tk.Toplevel()
    usuario.title('SIIE - Gerenciamento de Usuários')
    usuario.geometry('500x700')
    usuario.resizable(False, False)
    
    main_frame = tk.Frame(usuario)
    main_frame.pack(fill='both', expand=True)
    
    canvas = tk.Canvas(main_frame)
    scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)
    
    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )
    
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)
    
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")
    
    def _on_mousewheel(event):
        canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    
    canvas.bind_all("<MouseWheel>", _on_mousewheel)
    
    titulo_frame = tk.Frame(scrollable_frame, padx=20)
    titulo_frame.pack(fill='x', pady=(20, 10))
    
    tk.Label(titulo_frame, text='GERENCIAMENTO DE USUÁRIOS', 
             font=('Times New Roman', 18, 'bold')).pack()
    tk.Label(titulo_frame, text='Adicione, edite ou remova usuários do sistema',
             font=('Times New Roman', 10)).pack()
    
    lista_frame = tk.Frame(scrollable_frame, padx=20)
    lista_frame.pack(fill='both', expand=True, pady=(0, 20))
    
    tk.Label(lista_frame, text='Usuários Cadastrados:', 
             font=('Times New Roman', 12, 'bold')).pack(anchor='w')
    
    lista_container = tk.Frame(lista_frame)
    lista_container.pack(fill='both', expand=True, pady=5)
    
    lista_usuarios = tk.Listbox(lista_container, font=('Times New Roman', 11), height=8)
    scrollbar_lista = tk.Scrollbar(lista_container)
    lista_usuarios.configure(yscrollcommand=scrollbar_lista.set)
    scrollbar_lista.config(command=lista_usuarios.yview)
    
    lista_usuarios.pack(side='left', fill='both', expand=True)
    scrollbar_lista.pack(side='right', fill='y')
    
    def atualizar_lista():
        lista_usuarios.delete(0, tk.END)
        usuarios_carregados = carregar_usuarios()
        for nome, info in usuarios_carregados.items():
            matricula = info.get('matricula', 'N/A')
            lista_usuarios.insert(tk.END, f"{nome} | Matrícula: {matricula}")
    
    atualizar_lista()
    
    form_frame = tk.Frame(scrollable_frame, padx=20)
    form_frame.pack(fill='x', pady=(0, 20))
    
    tk.Label(form_frame, text='Novo Usuário:', 
             font=('Times New Roman', 12, 'bold')).pack(anchor='w', pady=(0, 10))
    
    campos = [
        ("Nome Completo*:", "entry_nome"),
        ("Data Nascimento:", "entry_nasc"),
        ("Estágio Obrigatório?:", "entry_estagio"),
        ("Matrícula*:", "entry_matricula"),
        ("Email:", "entry_email"),
        ("Supervisor:", "entry_supervisor")
    ]
    
    entries = {}
    for i, (label_text, var_name) in enumerate(campos):
        frame_campo = tk.Frame(form_frame)
        frame_campo.pack(fill='x', pady=3)
        
        tk.Label(frame_campo, text=label_text, width=18, anchor='w', font=('Times New Roman', 10)).pack(side='left')
        entry = tk.Entry(frame_campo, font=('Times New Roman', 10), width=30)
        entry.pack(side='left', padx=5, fill='x', expand=True)
        entries[var_name] = entry
    
    def adicionar_usuario():
        nome = entries['entry_nome'].get().strip()
        matricula = entries['entry_matricula'].get().strip()
        
        if not nome:
            messagebox.showerror("Erro", "Nome é obrigatório!")
            return
        if not matricula:
            messagebox.showerror("Erro", "Matrícula é obrigatória!")
            return
        
        usuarios_atual = carregar_usuarios()
        
        if nome in usuarios_atual:
            if not messagebox.askyesno("Confirmar", f"Usuário {nome} já existe. Substituir?"):
                return
        
        usuarios_atual[nome] = {
            'nascimento': entries['entry_nasc'].get(),
            'estagio': entries['entry_estagio'].get(),
            'matricula': matricula,
            'email': entries['entry_email'].get(),
            'supervisor': entries['entry_supervisor'].get(),
            'data_cadastro': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        
        salvar_usuarios(usuarios_atual)
        atualizar_lista()
        
        for entry in entries.values():
            entry.delete(0, tk.END)
        
        messagebox.showinfo("Sucesso", f"Usuário {nome} adicionado!")
    
    def remover_usuario():
        selecao = lista_usuarios.curselection()
        if not selecao:
            messagebox.showwarning("Aviso", "Selecione um usuário para remover!")
            return
        
        item = lista_usuarios.get(selecao[0])
        nome = item.split(' | ')[0]
        
        if messagebox.askyesno("Confirmar", f"Remover usuário {nome}?"):
            usuarios_atual = carregar_usuarios()
            if nome in usuarios_atual:
                del usuarios_atual[nome]
                salvar_usuarios(usuarios_atual)
                atualizar_lista()
                messagebox.showinfo("Sucesso", f"Usuário {nome} removido!")
    
    def editar_usuario():
        selecao = lista_usuarios.curselection()
        if not selecao:
            messagebox.showwarning("Aviso", "Selecione um usuário para editar!")
            return
        
        item = lista_usuarios.get(selecao[0])
        nome = item.split(' | ')[0]
        
        usuarios_atual = carregar_usuarios()
        if nome in usuarios_atual:
            info = usuarios_atual[nome]
            
            entries['entry_nome'].delete(0, tk.END)
            entries['entry_nome'].insert(0, nome)
            entries['entry_nasc'].delete(0, tk.END)
            entries['entry_nasc'].insert(0, info.get('nascimento', ''))
            entries['entry_estagio'].delete(0, tk.END)
            entries['entry_estagio'].insert(0, info.get('estagio', ''))
            entries['entry_matricula'].delete(0, tk.END)
            entries['entry_matricula'].insert(0, info.get('matricula', ''))
            entries['entry_email'].delete(0, tk.END)
            entries['entry_email'].insert(0, info.get('email', ''))
            entries['entry_supervisor'].delete(0, tk.END)
            entries['entry_supervisor'].insert(0, info.get('supervisor', ''))
            
            messagebox.showinfo("Editar", f"Preencha os campos para editar {nome}")
    
    acoes_frame = tk.Frame(scrollable_frame, padx=20)
    acoes_frame.pack(fill='x', pady=(0, 20))
    
    tk.Button(acoes_frame, text="Adicionar", font=('Times New Roman', 10),
              command=adicionar_usuario, bg='#4CAF50', fg='white',
              padx=15, pady=5).pack(side='left', padx=5)
    
    tk.Button(acoes_frame, text="Editar", font=('Times New Roman', 10),
              command=editar_usuario, bg='#FF9800', fg='white',
              padx=15, pady=5).pack(side='left', padx=5)
    
    tk.Button(acoes_frame, text="Remover", font=('Times New Roman', 10),
              command=remover_usuario, bg='#F44336', fg='white',
              padx=15, pady=5).pack(side='left', padx=5)
    
    tk.Button(acoes_frame, text="Atualizar Lista", font=('Times New Roman', 10),
              command=atualizar_lista, bg='#2196F3', fg='white',
              padx=15, pady=5).pack(side='left', padx=5)
    
    def voltar_usuarios():
        usuario.destroy()
        app.deiconify()
    
    tk.Button(scrollable_frame, text="Voltar ao Menu Principal", font=('Times New Roman', 10),
              command=voltar_usuarios, bg='#757575', fg='white',
              padx=20, pady=8).pack(pady=20)
    
    usuario.protocol("WM_DELETE_WINDOW", voltar_usuarios)
    usuario.bind("<MouseWheel>", lambda e: canvas.yview_scroll(int(-1*(e.delta/120)), "units"))

# ========== INTERFACE DE GERENCIAMENTO DE CARTÕES RFID ==========
def gerenciar():
    app.withdraw()
    gerencia = tk.Toplevel()
    gerencia.title('SIIE - Gerenciamento de Cartões RFID')
    gerencia.geometry('500x700')
    gerencia.resizable(False, False)
    
    main_frame = tk.Frame(gerencia)
    main_frame.pack(fill='both', expand=True)
    
    canvas = tk.Canvas(main_frame)
    scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)
    
    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )
    
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)
    
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")
    
    def _on_mousewheel(event):
        canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    
    canvas.bind_all("<MouseWheel>", _on_mousewheel)
    
    titulo_frame = tk.Frame(scrollable_frame, padx=20)
    titulo_frame.pack(fill='x', pady=(20, 10))
    
    tk.Label(titulo_frame, text='GERENCIAMENTO DE CARTÕES RFID', 
             font=('Times New Roman', 18, 'bold')).pack()
    tk.Label(titulo_frame, text='Associe cartões RFID aos usuários',
             font=('Times New Roman', 10)).pack()
    
    serial_frame = tk.Frame(titulo_frame)
    serial_frame.pack(pady=10)
    
    tk.Button(serial_frame, text="Configurar Conexão Arduino", 
              font=('Times New Roman', 10, 'bold'),
              command=configuracao_serial, bg='#607D8B', fg='white',
              padx=15, pady=8).pack()
    
    cartoes_atual = carregar_cartoes()
    usuarios_atual = carregar_usuarios()
    nomes_usuarios = list(usuarios_atual.keys())
    
    cartao_vars = {}
    
    cartoes_frame = tk.Frame(scrollable_frame, padx=20)
    cartoes_frame.pack(fill='x', pady=10)
    
    for uid, info in cartoes_atual.items():
        frame_cartao = tk.Frame(cartoes_frame, relief='groove', borderwidth=2, 
                               bg='#f8f9fa', padx=15, pady=10)
        frame_cartao.pack(fill='x', pady=8, padx=5)
        
        uid_frame = tk.Frame(frame_cartao, bg='#f8f9fa')
        uid_frame.pack(fill='x', pady=(0, 10))
        
        tk.Label(uid_frame, text=f"Cartão UID: {uid}", 
                font=('Times New Roman', 11, 'bold'), bg='#f8f9fa').pack(side='left')
        
        var_ativo = tk.BooleanVar(value=info.get('ativo', True))
        check_ativo = tk.Checkbutton(uid_frame, text="Ativo", 
                                    variable=var_ativo,
                                    font=('Times New Roman', 9), bg='#f8f9fa')
        check_ativo.pack(side='right')
        
        tk.Label(frame_cartao, text="Usuário Associado:", 
                font=('Times New Roman', 10), bg='#f8f9fa').pack(anchor='w')
        
        combo_dono = ttk.Combobox(frame_cartao, 
                                 values=nomes_usuarios,
                                 font=('Times New Roman', 10),
                                 state='readonly')
        combo_dono.set(info.get('dono', ''))
        combo_dono.pack(fill='x', pady=5)
        
        dono_atual = info.get('dono', '')
        if dono_atual:
            status_text = f"Associado a: {dono_atual}"
        else:
            status_text = "Sem associação"
        
        tk.Label(frame_cartao, text=status_text, 
                font=('Times New Roman', 9), bg='#f8f9fa', fg='#666').pack(anchor='w')
        
        cartao_vars[uid] = {'ativo': var_ativo, 'dono_combo': combo_dono, 'uid': uid}
    
    botoes_frame = tk.Frame(scrollable_frame, padx=20)
    botoes_frame.pack(fill='x', pady=20)
    
    def salvar_alteracoes():
        for uid, vars in cartao_vars.items():
            cartoes_atual[uid]['ativo'] = vars['ativo'].get()
            cartoes_atual[uid]['dono'] = vars['dono_combo'].get()
        
        salvar_cartoes(cartoes_atual)
        messagebox.showinfo("Sucesso", "Alterações salvas com sucesso!")
    
    tk.Button(botoes_frame, text="Salvar Todas as Alterações", 
              font=('Times New Roman', 11, 'bold'),
              command=salvar_alteracoes, bg='#4CAF50', fg='white',
              padx=20, pady=10).pack(fill='x')
    
    # Função para editar UID de cartão
    def editar_uid_cartao_interface():
        selecao = None
        uid_antigo = None
        
        # Procura qual cartão está selecionado
        for uid, vars in cartao_vars.items():
            # Verifica se algum widget do cartão tem foco
            if vars['dono_combo'].focus_get() or any(str(vars['ativo']) in str(widget.focus_get()) for widget in [vars['ativo']._root]):
                selecao = uid
                break
        
        if not selecao:
            messagebox.showwarning("Aviso", "Selecione um cartão para editar o UID!")
            return
        
        uid_antigo = selecao
        
        # Janela para editar UID
        janela_editar = tk.Toplevel(gerencia)
        janela_editar.title("Editar UID do Cartão")
        janela_editar.geometry("400x300")
        janela_editar.resizable(False, False)
        
        main_frame_editar = tk.Frame(janela_editar, padx=20, pady=20)
        main_frame_editar.pack(fill='both', expand=True)
        
        tk.Label(main_frame_editar, text="EDITAR UID DO CARTÃO", 
                font=('Times New Roman', 16, 'bold')).pack(pady=(0, 20))
        
        tk.Label(main_frame_editar, text=f"UID Atual:", 
                font=('Times New Roman', 11)).pack(anchor='w')
        tk.Label(main_frame_editar, text=f"{uid_antigo}", 
                font=('Courier New', 11, 'bold'), fg='#2c3e50').pack(anchor='w', pady=(0, 20))
        
        tk.Label(main_frame_editar, text="Novo UID*:", 
                font=('Times New Roman', 11)).pack(anchor='w')
        entry_novo_uid = tk.Entry(main_frame_editar, font=('Times New Roman', 11))
        entry_novo_uid.pack(fill='x', pady=(0, 20))
        entry_novo_uid.focus_set()
        
        info_label = tk.Label(main_frame_editar, text="Formato: A7 D6 DE D7 (letras A-F, números 0-9, espaços)",
                             font=('Times New Roman', 9), fg='#666')
        info_label.pack(anchor='w', pady=(0, 20))
        
        def confirmar_edicao():
            uid_novo = entry_novo_uid.get().strip().upper()
            
            if not uid_novo:
                messagebox.showerror("Erro", "Digite o novo UID!")
                return
            
            sucesso, mensagem = editar_uid_cartao(uid_antigo, uid_novo)
            
            if sucesso:
                messagebox.showinfo("Sucesso", mensagem)
                janela_editar.destroy()
                gerencia.destroy()
                gerenciar()  # Recarrega a janela
            else:
                messagebox.showerror("Erro", mensagem)
        
        botoes_frame_editar = tk.Frame(main_frame_editar)
        botoes_frame_editar.pack(fill='x', pady=10)
        
        tk.Button(botoes_frame_editar, text="Confirmar Edição", 
                 command=confirmar_edicao, bg='#4CAF50', fg='white',
                 padx=15, pady=8, font=('Times New Roman', 10)).pack(side='left', padx=5)
        
        tk.Button(botoes_frame_editar, text="Cancelar", 
                 command=janela_editar.destroy, bg='#F44336', fg='white',
                 padx=15, pady=8, font=('Times New Roman', 10)).pack(side='right', padx=5)
    
    # Botão para editar UID
    tk.Button(botoes_frame, text="Editar UID do Cartão", 
              font=('Times New Roman', 11, 'bold'),
              command=editar_uid_cartao_interface, bg='#9C27B0', fg='white',
              padx=20, pady=10).pack(fill='x', pady=(10, 0))
    
    adicionar_frame = tk.Frame(scrollable_frame, padx=20)
    adicionar_frame.pack(fill='x', pady=20)
    
    tk.Label(adicionar_frame, text='ADICIONAR NOVO CARTÃO', 
             font=('Times New Roman', 14, 'bold')).pack(anchor='w', pady=(0, 10))
    
    form_novo_frame = tk.Frame(adicionar_frame)
    form_novo_frame.pack(fill='x')
    
    uid_frame = tk.Frame(form_novo_frame)
    uid_frame.pack(fill='x', pady=5)
    tk.Label(uid_frame, text="UID do Cartão*:", 
             font=('Times New Roman', 10), width=15, anchor='w').pack(side='left')
    entry_uid = tk.Entry(uid_frame, font=('Times New Roman', 10))
    entry_uid.pack(side='left', fill='x', expand=True, padx=5)
    
    user_frame = tk.Frame(form_novo_frame)
    user_frame.pack(fill='x', pady=5)
    tk.Label(user_frame, text="Usuário:", 
             font=('Times New Roman', 10), width=15, anchor='w').pack(side='left')
    combo_novo_user = ttk.Combobox(user_frame, values=nomes_usuarios,
                                  font=('Times New Roman', 10))
    combo_novo_user.pack(side='left', fill='x', expand=True, padx=5)
    
    ativo_var = tk.BooleanVar(value=True)
    check_novo_ativo = tk.Checkbutton(form_novo_frame, text="Cartão Ativo",
                                     variable=ativo_var, font=('Times New Roman', 10))
    check_novo_ativo.pack(anchor='w', pady=5)
    
    def adicionar_novo_cartao():
        uid = entry_uid.get().strip()
        dono = combo_novo_user.get()
        ativo = ativo_var.get()
        
        sucesso, mensagem = adicionar_cartao(uid, dono, ativo)
        
        if sucesso:
            messagebox.showinfo("Sucesso", mensagem)
            entry_uid.delete(0, tk.END)
            combo_novo_user.set('')
            ativo_var.set(True)
            gerencia.destroy()
            gerenciar()
        else:
            messagebox.showerror("Erro", mensagem)
    
    tk.Button(form_novo_frame, text="Adicionar Cartão", 
              font=('Times New Roman', 10, 'bold'),
              command=adicionar_novo_cartao, bg='#2196F3', fg='white',
              padx=15, pady=8).pack(pady=10)
    
    tk.Frame(scrollable_frame, height=2, bg='#ddd').pack(fill='x', padx=20, pady=10)
    
    registro_frame = tk.Frame(scrollable_frame, padx=20)
    registro_frame.pack(fill='x', pady=10)
    
    tk.Label(registro_frame, text='REGISTRO MANUAL DE PONTO', 
             font=('Times New Roman', 14, 'bold')).pack(anchor='w', pady=(0, 10))
    
    tk.Label(registro_frame, text='Registre entrada/saída manualmente:',
             font=('Times New Roman', 10)).pack(anchor='w')
    
    def abrir_registro_manual():
        janela_registro = tk.Toplevel(gerencia)
        janela_registro.title("Registro Manual de Ponto")
        janela_registro.geometry("400x500")
        janela_registro.resizable(False, False)
        
        main_frame_reg = tk.Frame(janela_registro, padx=20, pady=20)
        main_frame_reg.pack(fill='both', expand=True)
        
        tk.Label(main_frame_reg, text="Registro Manual", 
                font=('Times New Roman', 16, 'bold')).pack(pady=(0, 20))
        
        campos_reg = []
        
        tk.Label(main_frame_reg, text="Usuário*:", 
                font=('Times New Roman', 10)).pack(anchor='w')
        combo_user = ttk.Combobox(main_frame_reg, values=nomes_usuarios, 
                                 font=('Times New Roman', 10))
        combo_user.pack(fill='x', pady=(0, 15))
        campos_reg.append(combo_user)
        
        tk.Label(main_frame_reg, text="Data (DD/MM/AAAA)*:", 
                font=('Times New Roman', 10)).pack(anchor='w')
        entry_data = tk.Entry(main_frame_reg, font=('Times New Roman', 10))
        entry_data.insert(0, datetime.now().strftime("%d/%m/%Y"))
        entry_data.pack(fill='x', pady=(0, 15))
        campos_reg.append(entry_data)
        
        tk.Label(main_frame_reg, text="Hora Entrada (HH:MM)*:", 
                font=('Times New Roman', 10)).pack(anchor='w')
        entry_entrada = tk.Entry(main_frame_reg, font=('Times New Roman', 10))
        entry_entrada.insert(0, "08:00")
        entry_entrada.pack(fill='x', pady=(0, 15))
        campos_reg.append(entry_entrada)
        
        tk.Label(main_frame_reg, text="Hora Saída (HH:MM)*:", 
                font=('Times New Roman', 10)).pack(anchor='w')
        entry_saida = tk.Entry(main_frame_reg, font=('Times New Roman', 10))
        entry_saida.insert(0, "17:00")
        entry_saida.pack(fill='x', pady=(0, 15))
        campos_reg.append(entry_saida)
        
        tk.Label(main_frame_reg, text="Cartão UID:", 
                font=('Times New Roman', 10)).pack(anchor='w')
        combo_cartao = ttk.Combobox(main_frame_reg, 
                                   values=list(cartoes_atual.keys()), font=('Times New Roman', 10))
        combo_cartao.pack(fill='x', pady=(0, 20))
        campos_reg.append(combo_cartao)
        
        def salvar_registro():
            try:
                usuario = combo_user.get()
                data_str = entry_data.get()
                entrada_str = entry_entrada.get()
                saida_str = entry_saida.get()
                cartao = combo_cartao.get()
                
                if not all([usuario, data_str, entrada_str, saida_str]):
                    messagebox.showerror("Erro", "Preencha todos os campos obrigatórios!")
                    return
                
                df = carregar_dados_xlsx()
                
                entrada_dt = datetime.strptime(f"{data_str} {entrada_str}", "%d/%m/%Y %H:%M")
                saida_dt = datetime.strptime(f"{data_str} {saida_str}", "%d/%m/%Y %H:%M")
                
                if saida_dt <= entrada_dt:
                    messagebox.showerror("Erro", "Hora de saída deve ser maior que entrada!")
                    return
                
                horas = saida_dt - entrada_dt
                
                novo_registro = {
                    'Usuario': usuario,
                    'Data': data_str,
                    'Entrada': entrada_str,
                    'Saida': saida_str,
                    'Horas': str(horas),
                    'Cartao': cartao if cartao else "Manual"
                }
                
                df = pd.concat([df, pd.DataFrame([novo_registro])], ignore_index=True)
                salvar_dados_xlsx(df)
                
                messagebox.showinfo("Sucesso", "Ponto registrado com sucesso!")
                janela_registro.destroy()
                
            except ValueError:
                messagebox.showerror("Erro", "Formato inválido! Use DD/MM/AAAA e HH:MM")
            except Exception as e:
                messagebox.showerror("Erro", f"Erro: {str(e)}")
        
        botoes_frame_reg = tk.Frame(main_frame_reg)
        botoes_frame_reg.pack(fill='x', pady=10)
        
        tk.Button(botoes_frame_reg, text="Salvar Registro", 
                 command=salvar_registro, bg='#4CAF50', fg='white',
                 padx=15, pady=8, font=('Times New Roman', 10)).pack(side='left')
        
        def fechar_registro():
            janela_registro.destroy()
        
        tk.Button(botoes_frame_reg, text="Cancelar", 
                 command=fechar_registro, bg='#F44336', fg='white',
                 padx=15, pady=8, font=('Times New Roman', 10)).pack(side='right')
    
    tk.Button(registro_frame, text="📝 Registrar Ponto Manual", 
              font=('Times New Roman', 10),
              command=abrir_registro_manual, bg='#2196F3', fg='white',
              padx=15, pady=8).pack()
    
    def voltar_gerencia():
        gerencia.destroy()
        app.deiconify()
    
    tk.Button(scrollable_frame, text="Voltar ao Menu Principal", 
              font=('Times New Roman', 10, 'bold'),
              command=voltar_gerencia, bg='#757575', fg='white',
              padx=20, pady=10).pack(pady=20)
    
    gerencia.protocol("WM_DELETE_WINDOW", voltar_gerencia)
    gerencia.bind("<MouseWheel>", lambda e: canvas.yview_scroll(int(-1*(e.delta/120)), "units"))

# ========== SIMULADOR RFID ==========
def simulador_rfid():
    """Função para simular leitura de cartões RFID"""
    app.withdraw()
    simulador = tk.Toplevel()
    simulador.title('SIIE - Simulador RFID')
    simulador.geometry('500x700')
    simulador.resizable(False, False)
    
    main_frame = tk.Frame(simulador)
    main_frame.pack(fill='both', expand=True)
    
    canvas = tk.Canvas(main_frame)
    scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = tk.Frame(canvas)
    
    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )
    
    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)
    
    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")
    
    def _on_mousewheel(event):
        canvas.yview_scroll(int(-1*(event.delta/120)), "units")
    
    canvas.bind_all("<MouseWheel>", _on_mousewheel)
    
    content_frame = tk.Frame(scrollable_frame, padx=20, pady=20)
    content_frame.pack(fill='both', expand=True)
    
    tk.Label(content_frame, text='SIMULADOR RFID', 
             font=('Times New Roman', 18, 'bold')).pack(pady=(0, 10))
    
    tk.Label(content_frame, text='Simule a leitura de cartões RFID para testes',
             font=('Times New Roman', 10)).pack(pady=(0, 20))
    
    cartoes_atual = carregar_cartoes()
    
    selecao_frame = tk.Frame(content_frame)
    selecao_frame.pack(fill='x', pady=10)
    
    tk.Label(selecao_frame, text="Selecione o cartão:", 
             font=('Times New Roman', 11)).pack(anchor='w')
    
    combo_cartoes = ttk.Combobox(selecao_frame, 
                                 values=list(cartoes_atual.keys()),
                                 font=('Times New Roman', 11))
    combo_cartoes.pack(fill='x', pady=5)
    
    info_frame = tk.Frame(content_frame, relief='groove', borderwidth=2, 
                         bg='#f0f0f0', padx=15, pady=15)
    info_frame.pack(fill='x', pady=20)
    
    info_text = tk.StringVar()
    info_text.set("Selecione um cartão para ver informações")
    
    tk.Label(info_frame, textvariable=info_text, 
             font=('Times New Roman', 10), bg='#f0f0f0', 
             wraplength=400, justify='left').pack()
    
    resultado_frame = tk.Frame(content_frame, bg='#e8f5e9', 
                              relief='solid', borderwidth=1)
    resultado_frame.pack(fill='x', pady=10)
    
    resultado_text = tk.StringVar()
    resultado_text.set("")
    
    tk.Label(resultado_frame, textvariable=resultado_text, 
             font=('Times New Roman', 11, 'bold'), bg='#e8f5e9',
             padx=10, pady=10).pack()
    
    historico_frame = tk.Frame(content_frame)
    historico_frame.pack(fill='both', expand=True, pady=20)
    
    tk.Label(historico_frame, text='Histórico de Simulações:', 
             font=('Times New Roman', 12, 'bold')).pack(anchor='w', pady=(0, 10))
    
    historico_text = tk.Text(historico_frame, height=8, font=('Courier New', 9), wrap=tk.WORD)
    scrollbar_historico = tk.Scrollbar(historico_frame)
    historico_text.configure(yscrollcommand=scrollbar_historico.set)
    scrollbar_historico.config(command=historico_text.yview)
    
    historico_text.pack(side='left', fill='both', expand=True)
    scrollbar_historico.pack(side='right', fill='y')
    
    def atualizar_info():
        uid = combo_cartoes.get()
        if not uid:
            info_text.set("Selecione um cartão para ver informações")
            return
        
        cartao_info = cartoes_atual.get(uid, {})
        dono = cartao_info.get('dono', '')
        ativo = cartao_info.get('ativo', False)
        
        status = "ATIVO" if ativo else "INATIVO"
        dono_info = f"{dono}" if dono else "Sem dono"
        
        info_text.set(f"Cartão: {uid}\nStatus: {status}\n{dono_info}")
    
    combo_cartoes.bind('<<ComboboxSelected>>', lambda e: atualizar_info())
    
    def registrar_leitura():
        uid = combo_cartoes.get()
        if not uid:
            messagebox.showwarning("Aviso", "Selecione um cartão!")
            return
        
        cartao_info = cartoes_atual.get(uid)
        if not cartao_info:
            resultado_text.set("Cartão não encontrado!")
            return
        
        if not cartao_info.get('ativo', True):
            resultado_text.set("Cartão INATIVO!")
            return
        
        dono = cartao_info.get('dono', '')
        if not dono:
            resultado_text.set("Cartão sem dono associado!")
            return
        
        agora = datetime.now()
        data_str = agora.strftime("%d/%m/%Y")
        hora_str = agora.strftime("%H:%M")
        
        df = carregar_dados_xlsx()
        
        registros_hoje = df[
            (df['Usuario'] == dono) & 
            (df['Data'] == data_str)
        ]
        
        if registros_hoje.empty or registros_hoje['Saida'].notna().all():
            novo_registro = {
                'Usuario': dono,
                'Data': data_str,
                'Entrada': hora_str,
                'Saida': '',
                'Horas': '',
                'Cartao': uid
            }
            df = pd.concat([df, pd.DataFrame([novo_registro])], ignore_index=True)
            resultado = f"ENTRADA registrada\n{dono}\n{hora_str}"
            resultado_text.set(resultado)
            historico_text.insert(tk.END, f"[{hora_str}] ENTRADA: {dono} ({uid})\n")
        else:
            idx = registros_hoje.index[-1]
            entrada_str = df.at[idx, 'Entrada']
            df.at[idx, 'Saida'] = hora_str
            
            try:
                entrada_dt = datetime.strptime(f"{data_str} {entrada_str}", "%d/%m/%Y %H:%M")
                saida_dt = datetime.strptime(f"{data_str} {hora_str}", "%d/%m/%Y %H:%M")
                horas = saida_dt - entrada_dt
                df.at[idx, 'Horas'] = str(horas)
                
                horas_total = horas.seconds // 3600
                minutos_total = (horas.seconds % 3600) // 60
                resultado = f"SAÍDA registrada\n{dono}\n{hora_str}\nTotal: {horas_total}h{minutos_total:02d}min"
                resultado_text.set(resultado)
                historico_text.insert(tk.END, f"[{hora_str}] SAÍDA: {dono} - Total: {horas_total}h{minutos_total:02d}min\n")
            except:
                df.at[idx, 'Horas'] = 'Erro no cálculo'
                resultado = f"SAÍDA registrada\n{dono}\n{hora_str}"
                resultado_text.set(resultado)
                historico_text.insert(tk.END, f"[{hora_str}] SAÍDA: {dono} (Erro no cálculo)\n")
        
        salvar_dados_xlsx(df)
        atualizar_info()
        historico_text.see(tk.END)
    
    botoes_frame = tk.Frame(content_frame)
    botoes_frame.pack(fill='x', pady=20)
    
    tk.Button(botoes_frame, text="Simular Leitura RFID", 
              font=('Times New Roman', 11, 'bold'),
              command=registrar_leitura, bg='#9C27B0', fg='white',
              padx=20, pady=10).pack(fill='x')
    
    def limpar_historico():
        historico_text.delete(1.0, tk.END)
    
    tk.Button(botoes_frame, text="Limpar Histórico", 
              font=('Times New Roman', 10),
              command=limpar_historico, bg='#757575', fg='white',
              padx=15, pady=8).pack(pady=10)
    
    def voltar_simulador():
        simulador.destroy()
        app.deiconify()
    
    tk.Button(content_frame, text="Voltar ao Menu Principal", 
              font=('Times New Roman', 10),
              command=voltar_simulador, bg='#757575', fg='white',
              padx=15, pady=8).pack(pady=10)
    
    simulador.protocol("WM_DELETE_WINDOW", voltar_simulador)
    simulador.bind("<MouseWheel>", lambda e: canvas.yview_scroll(int(-1*(e.delta/120)), "units"))

# ========== SAIR DO APLICATIVO ==========
def sair_aplicativo():
    """Função para sair do aplicativo"""
    if messagebox.askyesno("Sair", "Deseja realmente sair do SIIE?"):
        parar_conexao_automatica()
        desconectar_arduino()
        app.quit()

# ========== INTERFACE PRINCIPAL ==========
# Configuração de cores para a interface principal
app.configure(bg='#2c3e50')

main_content = tk.Frame(app, bg='white')
main_content.place(relx=0.5, rely=0.5, anchor='center', width=450, height=600)

header_frame = tk.Frame(main_content, bg='#3498db', height=100)
header_frame.pack(fill='x')
header_frame.pack_propagate(False)

tk.Label(header_frame, text='SIIE', font=('Times New Roman', 32, 'bold'), 
         bg='#3498db', fg='white').pack(expand=True)

tk.Label(header_frame, text='Sistema Interno de Informações de Estagio', 
         font=('Times New Roman', 10), bg='#3498db', fg='white').pack(pady=(0, 10))

buttons_frame = tk.Frame(main_content, bg='white', padx=30, pady=30)
buttons_frame.pack(fill='both', expand=True)

botoes_menu = [
    ("Dados e Relatórios", dadoss, "#2ecc71"),
    ("Gerenciar Usuários", usuarios, "#e74c3c"),
    ("Gerenciar Cartões RFID", gerenciar, "#f39c12"),
    ("Configurar Conexão Arduino", configuracao_serial, "#607D8B"),
    ("Simulador RFID", simulador_rfid, "#9b59b6"),
    ("Sair do Sistema", sair_aplicativo, "#7f8c8d")
]

for texto, comando, cor in botoes_menu:
    btn = tk.Button(buttons_frame, text=texto, font=('Times New Roman', 12, 'bold'),
                    command=comando, bg=cor, fg='white',
                    padx=20, pady=12, width=25,
                    cursor='hand2')
    btn.pack(pady=8)
    btn.bind("<Enter>", lambda e, b=btn: b.config(bg='#34495e'))
    btn.bind("<Leave>", lambda e, b=btn, c=cor: b.config(bg=c))

status_frame = tk.Frame(main_content, bg='#ecf0f1', height=80)
status_frame.pack(fill='x', side='bottom')
status_frame.pack_propagate(False)

status_inner = tk.Frame(status_frame, bg='#ecf0f1', padx=20, pady=10)
status_inner.pack(expand=True)

usuarios_status = carregar_usuarios()
cartoes_status = carregar_cartoes()
dados_status = carregar_dados_xlsx()

tk.Label(status_inner, text=f" {len(usuarios_status)} usuários | ", 
         font=('Times New Roman', 9), bg='#ecf0f1').pack(side='left')
tk.Label(status_inner, text=f" {len(cartoes_status)} cartões | ", 
         font=('Times New Roman', 9), bg='#ecf0f1').pack(side='left')
tk.Label(status_inner, text=f" {len(dados_status)} registros", 
         font=('Times New Roman', 9), bg='#ecf0f1').pack(side='left')

notif_frame = tk.Frame(status_frame, bg='#ecf0f1')
notif_frame.pack(fill='x', padx=20, pady=(5, 0))

notif_label = tk.Label(notif_frame, textvariable=notif_var, 
                      font=('Times New Roman', 9), bg='#ecf0f1', fg='gray',
                      wraplength=410, justify='center')
notif_label.pack()
app.notif_label = notif_label

footer_frame = tk.Frame(app, bg='#2c3e50', height=30)
footer_frame.pack(side='bottom', fill='x')
footer_frame.pack_propagate(False)

tk.Label(footer_frame, text='SIIE v3.0 © 2025 - Sistema Interno de Informações de Estagio', 
         font=('Times New Roman', 8), bg='#2c3e50', fg='#bdc3c7').pack(expand=True)

app.eval('tk::PlaceWindow . center')

print("SIIE iniciando...")
log_event("Sistema SIIE iniciado")

app.after(2000, lambda: iniciar_conexao_automatica())

app.mainloop()
